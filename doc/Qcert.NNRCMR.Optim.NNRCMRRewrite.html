
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Qcert.NNRCMR.Optim.NNRCMRRewrite</title>
<meta name="description" content="Documentation of Coq module Qcert.NNRCMR.Optim.NNRCMRRewrite" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Qcert.NNRCMR.Optim.NNRCMRRewrite</h1>
<div class="coq">
<br/>
<span class="kwd">Section</span> <span class="id">NNRCMRRewrite</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">String</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Arith</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">EquivDec</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Utils</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">BasicRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">cNNRCRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">NNRCRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">NNRCMR</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ForeignReduceOps</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">list_scope</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> {<span class="id">fruntime</span>:<span class="id">foreign_runtime</span>}.<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> {<span class="id">fredop</span>:<span class="id">foreign_reduce_op</span>}.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> (<span class="id">h</span>:<span class="id">list</span>(<span class="id">string</span>*<span class="id">string</span>)).<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_function</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCVar</span> <span class="id">y</span> =&gt; <span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCUnop</span> <span class="id">AIdOp</span> (<span class="id">NNRCVar</span> <span class="id">y</span>) =&gt; <span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_coll_function</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCUnop</span> <span class="id">AColl</span> (<span class="id">NNRCVar</span> <span class="id">y</span>) =&gt; <span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_constant_function</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCConst</span> <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_flatten_function</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCUnop</span> <span class="id">AFlatten</span> (<span class="id">NNRCVar</span> <span class="id">y</span>) =&gt; <span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCLet</span> <span class="id">a</span> (<span class="id">NNRCUnop</span> <span class="id">AFlatten</span> (<span class="id">NNRCVar</span> <span class="id">y</span>)) (<span class="id">NNRCVar</span> <span class="id">b</span>) =&gt; <span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span> &amp;&amp; <span class="id">equiv_decb</span> <span class="id">a</span> <span class="id">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">is_flatten_function_correct</span> (<span class="id">x</span>:<span class="id">var</span>) (<span class="id">n</span>:<span class="id">nnrc</span>) (<span class="id">env</span>:<span class="id">bindings</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_flatten_function</span> (<span class="id">x</span>,<span class="id">n</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lookup</span> <span class="id">equiv_dec</span> <span class="id">env</span> <span class="id">x</span> = <span class="id">Some</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> <span class="id">env</span> <span class="id">n</span>) = <span class="id">lift_oncoll</span> (<span class="kwd">fun</span> <span class="id">l</span> =&gt; (<span class="id">lift</span> <span class="id">dcoll</span> (<span class="id">rflatten</span> <span class="id">l</span>))) <span class="id">d</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2604')">Proof.</div>
<div class="proofscript" id="proof2604">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hfun</span> <span class="id">d</span> <span class="id">Henv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Henv</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n2</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Hfun</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hfun</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Henv</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">lift_oncoll</span> (<span class="kwd">fun</span> <span class="id">l</span> : <span class="id">list</span> <span class="id">data</span> =&gt; <span class="id">lift</span> <span class="id">dcoll</span> (<span class="id">rflatten</span> <span class="id">l</span>)) <span class="id">d</span>); <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_uncoll_function_arg</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCLet</span> <span class="id">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NNRCEither</span> (<span class="id">NNRCUnop</span> <span class="id">ASingleton</span> (<span class="id">NNRCVar</span> <span class="id">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">b</span> (<span class="id">NNRCVar</span> <span class="id">b</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">c</span> (<span class="id">NNRCConst</span> <span class="id">dunit</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">equiv_decb</span> <span class="id">x</span> <span class="id">y</span> &amp;&amp; <span class="id">equiv_decb</span> <span class="id">b</span> <span class="id">b</span>' &amp;&amp; <span class="id">equiv_decb</span> <span class="id">a</span> <span class="id">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_scalar_map</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDist</span> <span class="id">f</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDistFlatten</span> <span class="id">f</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> <span class="id">f</span> =&gt; <span class="id">is_coll_function</span> <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">id_scalar_map_correct</span> <span class="id">mr_map</span> <span class="id">d</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_scalar_map</span> <span class="id">mr_map</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_map_eval</span> <span class="id">h</span> <span class="id">mr_map</span> (<span class="id">Dlocal</span> <span class="id">d</span>) = <span class="id">Some</span> (<span class="id">d</span>::<span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2605')">Proof.</div>
<div class="proofscript" id="proof2605">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">H_is_id_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_dist_map</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDist</span> <span class="id">f</span> =&gt; <span class="id">is_id_function</span> <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDistFlatten</span> <span class="id">f</span> =&gt; <span class="id">is_coll_function</span> <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">id_dist_map_correct</span> <span class="id">mr_map</span> <span class="id">coll</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_dist_map</span> <span class="id">mr_map</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_map_eval</span> <span class="id">h</span> <span class="id">mr_map</span> (<span class="id">Ddistr</span> <span class="id">coll</span>) = <span class="id">Some</span> <span class="id">coll</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2606')">Proof.</div>
<div class="proofscript" id="proof2606">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">H_is_id_dist_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">MapDist</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rmap_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rmap_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">MapDistFlatten</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">alg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">MapScalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H_is_id_dist_map</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_dispatch_map</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> <span class="id">f</span> =&gt; <span class="id">is_id_function</span> <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">dispatch_map_correct</span> <span class="id">mr_map</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_dispatch_map</span> <span class="id">mr_map</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_map_eval</span> <span class="id">h</span> <span class="id">mr_map</span> (<span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">coll</span>)) = <span class="id">Some</span> <span class="id">coll</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2607')">Proof.</div>
<div class="proofscript" id="proof2607">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_map_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_scalar_map</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_flatten_dist_map</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDistFlatten</span> <span class="id">f</span> =&gt; <span class="id">is_id_function</span> <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">flatten_dist_map_correct</span> <span class="id">mr_map</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_flatten_dist_map</span> <span class="id">mr_map</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_map_eval</span> <span class="id">h</span> <span class="id">mr_map</span> (<span class="id">Ddistr</span> <span class="id">coll</span>) = <span class="id">rflatten</span> <span class="id">coll</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2608')">Proof.</div>
<div class="proofscript" id="proof2608">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_map_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">rmap_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">rmap_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_flatten_collect</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">is_flatten_function</span> <span class="id">reduce</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_reduce</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">id_reduce_correct</span> <span class="tactic">red</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_reduce</span> <span class="tactic">red</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_reduce_eval</span> <span class="id">h</span> <span class="tactic">red</span> <span class="id">coll</span> = <span class="id">Some</span> (<span class="id">Ddistr</span> <span class="id">coll</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2609')">Proof.</div>
<div class="proofscript" id="proof2609">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_collect</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">is_id_function</span> <span class="id">reduce</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">id_collect_correct</span> <span class="tactic">red</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_collect</span> <span class="tactic">red</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_reduce_eval</span> <span class="id">h</span> <span class="tactic">red</span> <span class="id">coll</span> = <span class="id">Some</span> (<span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">coll</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2610')">Proof.</div>
<div class="proofscript" id="proof2610">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="tactic">red</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [<span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span>; <span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_singleton_reduce</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">singleton_reduce_correct</span> <span class="tactic">red</span> <span class="id">d</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_singleton_reduce</span> <span class="tactic">red</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_reduce_eval</span> <span class="id">h</span> <span class="tactic">red</span> (<span class="id">d</span>::<span class="id">nil</span>) = <span class="id">Some</span> (<span class="id">Dlocal</span> <span class="id">d</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2611')">Proof.</div>
<div class="proofscript" id="proof2611">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="tactic">red</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [<span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span>; <span class="tactic">congruence</span>].<br/>
&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_uncoll_collect</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">is_uncoll_function_arg</span> <span class="id">reduce</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">suppress_uncoll_in_collect_reduce</span> <span class="tactic">red</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="tactic">red</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">f</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">is_uncoll_function_arg</span> <span class="id">f</span> <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">x</span>, <span class="id">n</span>) := <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">NNRCLet</span> <span class="id">a</span> <span class="id">_</span> <span class="id">n</span>' =&gt; <span class="id">Some</span> (<span class="id">RedCollect</span> (<span class="id">a</span>, <span class="id">n</span>'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">suppress_uncoll_in_collect_reduce_correct</span> <span class="id">reduce</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">reduce</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reduce_well_formed</span> <span class="id">reduce</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_uncoll_collect</span> <span class="id">reduce</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suppress_uncoll_in_collect_reduce</span> <span class="id">reduce</span> = <span class="id">Some</span> <span class="id">reduce</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_reduce_eval</span> <span class="id">h</span> <span class="id">reduce</span> (<span class="id">dcoll</span> <span class="id">coll</span> :: <span class="id">nil</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_reduce_eval</span> <span class="id">h</span> <span class="id">reduce</span>' <span class="id">coll</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2612')">Proof.</div>
<div class="proofscript" id="proof2612">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">reduce</span>' <span class="id">Hwf</span> <span class="id">Hred</span> <span class="id">Hred</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [<span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span>; <span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1_1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1_2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1_1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1_3</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hred</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hred</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Hred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hred</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">e0</span> <span class="id">e</span> <span class="id">H</span> <span class="id">H1</span> <span class="id">H2</span> <span class="id">Hred</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">dcoll</span> <span class="id">coll</span>) :: (<span class="id">v</span>, <span class="id">dcoll</span> (<span class="id">dcoll</span> <span class="id">coll</span> :: <span class="id">nil</span>)) :: <span class="id">nil</span>) <span class="id">n2</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">dcoll</span> <span class="id">coll</span>) :: <span class="id">nil</span>) <span class="id">n2</span>) <span class="kwd">as</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="tactic">rewrite</span> &lt;- <span class="id">Heq</span>; <span class="tactic">reflexivity</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">nnrc_core_eval_equiv_free_in_env</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">x</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">lookup</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_dist_mr</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">is_id_dist_map</span> <span class="id">mr</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">is_id_dist_mr_correct</span> (<span class="id">mr</span>:<span class="id">mr</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_dist_mr</span> <span class="id">mr</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">loc_d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc_d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ddistr</span> <span class="id">coll</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">Ddistr</span> <span class="id">coll</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Dlocal</span> <span class="id">d</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">Ddistr</span> (<span class="id">d</span>::<span class="id">nil</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2613')">Proof.</div>
<div class="proofscript" id="proof2613">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">H_is_id_mr</span> <span class="id">loc_d</span> <span class="id">H_well_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_id_dist_mr</span> <span class="kwd">in</span> <span class="id">H_is_id_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_dist_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H_is_id_mr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_id_scalar_mr</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">op</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">is_id_scalar_map</span> <span class="id">mr</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">is_id_scalar_mr_correct</span> (<span class="id">mr</span>:<span class="id">mr</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_scalar_mr</span> <span class="id">mr</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">loc_d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc_d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ddistr</span> <span class="id">coll</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Dlocal</span> <span class="id">d</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">Dlocal</span> <span class="id">d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2614')">Proof.</div>
<div class="proofscript" id="proof2614">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">H_is_id_mr</span> <span class="id">loc_d</span> <span class="id">H_well_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_id_scalar_mr</span> <span class="kwd">in</span> <span class="id">H_is_id_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_scalar_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H_is_id_mr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_kindofflatten_mr</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_dist_map</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) &amp;&amp; <span class="id">is_flatten_collect</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">is_kindofflatten_mr_correct</span> (<span class="id">mr</span>:<span class="id">mr</span>) (<span class="id">loc_d</span>: <span class="id">ddata</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_kindofflatten_mr</span> <span class="id">mr</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc_d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ddistr</span> <span class="id">coll</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">l</span> =&gt; <span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">l</span>)) (<span class="id">rflatten</span> <span class="id">coll</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Dlocal</span> <span class="id">d</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">l</span> =&gt; <span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">l</span>)) (<span class="id">rflatten</span> (<span class="id">d</span>::<span class="id">nil</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2615')">Proof.</div>
<div class="proofscript" id="proof2615">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmr</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_kindofflatten_mr</span> <span class="kwd">in</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_flatten_collect</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_dist_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rflatten</span> <span class="id">l</span>); <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n2</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rflatten</span> <span class="id">l</span>); <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_collect_mr</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_dist_map</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) &amp;&amp; <span class="id">is_id_collect</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">mr_collect_collects</span> (<span class="id">mr</span>:<span class="id">mr</span>) (<span class="id">loc_d</span>:<span class="id">ddata</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_collect_mr</span> <span class="id">mr</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">loc_d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ddistr</span> <span class="id">coll</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">coll</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Dlocal</span> <span class="id">d</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">Dlocal</span> (<span class="id">dcoll</span> (<span class="id">d</span>::<span class="id">nil</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2616')">Proof.</div>
<div class="proofscript" id="proof2616">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmr</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_collect_mr</span> <span class="kwd">in</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>.<br/>
&nbsp;-&nbsp;Case&nbsp;"loc_d&nbsp;is&nbsp;scalar"%string.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;rewrite&nbsp;Hmap;&nbsp;simpl.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;destruct&nbsp;p;&nbsp;simpl&nbsp;in&nbsp;*.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;destruct&nbsp;n;&nbsp;simpl&nbsp;in&nbsp;*;&nbsp;try&nbsp;congruence.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;*&nbsp;unfold&nbsp;equiv_decb&nbsp;in&nbsp;*.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;dest_eqdec;&nbsp;try&nbsp;congruence.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;*&nbsp;destruct&nbsp;u;&nbsp;simpl&nbsp;in&nbsp;*;&nbsp;try&nbsp;congruence.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;n;&nbsp;simpl&nbsp;in&nbsp;*;&nbsp;try&nbsp;congruence.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;equiv_decb&nbsp;in&nbsp;*.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;dest_eqdec;&nbsp;try&nbsp;congruence.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflexivity.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_dist_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">is_dispatch_mr</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedId</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_dispatch_map</span> <span class="id">mr</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedCollect</span> <span class="id">reduce</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedOp</span> <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">RedSingleton</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">mr_dispatch_correct</span> (<span class="id">mr</span>:<span class="id">mr</span>) (<span class="id">coll</span>:<span class="id">list</span> <span class="id">data</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_dispatch_mr</span> <span class="id">mr</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_eval</span> <span class="id">h</span> <span class="id">mr</span> (<span class="id">Dlocal</span> (<span class="id">dcoll</span> <span class="id">coll</span>)) = <span class="id">Some</span> (<span class="id">Ddistr</span> <span class="id">coll</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2617')">Proof.</div>
<div class="proofscript" id="proof2617">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_dispatch_mr</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_dispatch_map</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dispatch_map_correct</span>; [|<span class="tactic">assumption</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_reduce_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rflatten</span> <span class="id">coll</span>); <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">map_collect_flatten_to_map_flatten_collect</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDist</span> <span class="id">f</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">is_flatten_collect</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span>' :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MapDistFlatten</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RedCollect</span> <span class="id">id_function</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">mr</span>'::<span class="id">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">map_collect_flatten_to_map_flatten_collect_correct</span> <span class="id">mr</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mr_chain</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_collect_flatten_to_map_flatten_collect</span> <span class="id">mr</span> = <span class="id">Some</span> <span class="id">mr_chain</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">env</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_chain_eval</span> <span class="id">h</span> <span class="id">env</span> (<span class="id">mr</span>::<span class="id">nil</span>) = <span class="id">mr_chain_eval</span> <span class="id">h</span> <span class="id">env</span> <span class="id">mr_chain</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2618')">Proof.</div>
<div class="proofscript" id="proof2618">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr_chain</span> <span class="id">Hmr_chain</span> <span class="id">env</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">map_collect_flatten_to_map_flatten_collect</span> <span class="kwd">in</span> <span class="id">Hmr_chain</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_chain</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">is_flatten_collect</span> <span class="id">mr_reduce</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Heq</span>; <span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmr_chain</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">lookup</span> <span class="id">equiv_dec</span> <span class="id">env</span> <span class="id">mr_input</span>); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_reduce_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rmap</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">d0</span> : <span class="id">data</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">doc</span>, <span class="id">body</span>) := <span class="id">p</span> <span class="kwd">in</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">doc</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) <span class="id">body</span>) <span class="id">l</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rflatten</span> <span class="id">l0</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rmap</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">d</span> : <span class="id">data</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">doc</span>, <span class="id">body</span>) := <span class="id">p</span> <span class="kwd">in</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">doc</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">body</span>) <span class="id">l</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (@<span class="id">equiv_dec</span> <span class="id">string</span> (@<span class="id">eq</span> <span class="id">string</span>) (@<span class="id">eq_equivalence</span> <span class="id">string</span>) <span class="id">string_eqdec</span> <span class="id">v1</span> <span class="id">v</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (@<span class="id">equiv_dec</span> <span class="id">string</span> (@<span class="id">eq</span> <span class="id">string</span>) (@<span class="id">eq_equivalence</span> <span class="id">string</span>) <span class="id">string_eqdec</span> <span class="id">v2</span> <span class="id">v0</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rflatten</span> <span class="id">l0</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_correct</span> (<span class="id">mf</span>:<span class="id">mr</span> -&gt; <span class="id">mr</span> -&gt; <span class="id">option</span> <span class="id">mr</span>) (<span class="id">m1</span> <span class="id">m2</span>: <span class="id">mr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">m3</span>:<span class="id">mr</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m1</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m1</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m2</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m2</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m2</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m1</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mf</span> <span class="id">m1</span> <span class="id">m2</span> = <span class="id">Some</span> <span class="id">m3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">loc_d</span>: <span class="id">ddata</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">m1</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_mr_chain_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_eval</span> <span class="id">h</span> ((<span class="id">m1</span>.(<span class="id">mr_input</span>),<span class="id">loc_d</span>)::<span class="id">nil</span>) (<span class="id">m1</span>::<span class="id">m2</span>::<span class="id">nil</span>)) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_mr_chain_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_eval</span> <span class="id">h</span> ((<span class="id">m1</span>.(<span class="id">mr_input</span>),<span class="id">loc_d</span>)::<span class="id">nil</span>) (<span class="id">m3</span>::<span class="id">nil</span>)).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_correct_weak</span> (<span class="id">mf</span>:<span class="id">mr</span> -&gt; <span class="id">mr</span> -&gt; <span class="id">option</span> <span class="id">mr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">m1</span> <span class="id">m2</span> <span class="id">m3</span>:<span class="id">mr</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m1</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m1</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m2</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m2</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m2</span>.(<span class="id">mr_output</span>) &lt;&gt; <span class="id">m1</span>.(<span class="id">mr_input</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mf</span> <span class="id">m1</span> <span class="id">m2</span> = <span class="id">Some</span> <span class="id">m3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">loc_d</span>: <span class="id">ddata</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">result</span>: <span class="id">data</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_well_localized</span> <span class="id">m1</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_mr_chain_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_eval</span> <span class="id">h</span> ((<span class="id">m1</span>.(<span class="id">mr_input</span>),<span class="id">loc_d</span>)::<span class="id">nil</span>) (<span class="id">m1</span>::<span class="id">m2</span>::<span class="id">nil</span>)) = <span class="id">Some</span> <span class="id">result</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_mr_chain_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_eval</span> <span class="id">h</span> ((<span class="id">m1</span>.(<span class="id">mr_input</span>),<span class="id">loc_d</span>)::<span class="id">nil</span>) (<span class="id">m3</span>::<span class="id">nil</span>)) = <span class="id">Some</span> <span class="id">result</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_collect_dispatch</span> <span class="id">mr1</span> <span class="id">mr2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> (<span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_id_collect</span> <span class="id">mr1</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_dispatch_map</span> <span class="id">mr2</span>.(<span class="id">mr_map</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_collect_dispatch_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_collect_dispatch</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2619')">Proof.</div>
<div class="proofscript" id="proof2619">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_collect_dispatch</span> <span class="kwd">in</span> <span class="id">Hmerge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> ((<span class="id">mr_output</span> <span class="id">mr1</span> ==<span class="id">b</span> <span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_collect</span> (<span class="id">mr_reduce</span> <span class="id">mr1</span>) &amp;&amp; <span class="id">is_dispatch_map</span> (<span class="id">mr_map</span> <span class="id">mr2</span>)); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge</span>; <span class="tactic">clear</span> <span class="id">Hmerge</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">olift</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> ((<span class="id">mr_map_eval</span> <span class="id">h</span> (<span class="id">mr_map</span> <span class="id">mr1</span>) <span class="id">loc_d</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">coll</span> <span class="id">Hmap1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_collect_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr2</span>) (<span class="id">mr_output</span> <span class="id">mr1</span>)); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">dispatch_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>) <span class="id">coll</span>); <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">e1</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_mr_id_dist_l</span> <span class="id">mr1</span> <span class="id">mr2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>) &amp;&amp; <span class="id">is_id_dist_mr</span> <span class="id">mr1</span> <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_mr_id_dist_l_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_mr_id_dist_l</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2620')">Proof.</div>
<div class="proofscript" id="proof2620">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_mr_id_dist_l</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp; <span class="id">is_id_dist_mr</span> <span class="id">mr1</span>); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Hmr1_mr2</span>, <span class="id">Hmr1_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_id_dist_mr_correct</span> <span class="id">mr1</span> <span class="id">Hmr1_is_id</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_id_dist_mr</span> <span class="kwd">in</span> <span class="id">Hmr1_is_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hmr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">olift</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_map_eval</span> <span class="id">h</span> (<span class="id">NNRCMR.mr_map</span> <span class="id">mr2</span>) (<span class="id">Ddistr</span> <span class="id">l</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_mr_id_scalar_l</span> <span class="id">mr1</span> <span class="id">mr2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>) &amp;&amp; <span class="id">is_id_scalar_mr</span> <span class="id">mr1</span> <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_mr_id_scalar_l_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_mr_id_scalar_l</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2621')">Proof.</div>
<div class="proofscript" id="proof2621">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_mr_id_scalar_l</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp; <span class="id">is_id_scalar_mr</span> <span class="id">mr1</span>); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Hmr1_mr2</span>, <span class="id">Hmr1_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_id_scalar_mr_correct</span> <span class="id">mr1</span> <span class="id">Hmr1_is_id</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_id_scalar_mr</span> <span class="kwd">in</span> <span class="id">Hmr1_is_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_reduce</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">solve</span> [ <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">scalar</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Hmr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">olift</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_map_eval</span> <span class="id">h</span> (<span class="id">NNRCMR.mr_map</span> <span class="id">mr2</span>) (<span class="id">Dlocal</span> <span class="id">d</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d0</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id">Case</span> "<span class="id">loc_d</span> <span class="id">is</span> <span class="id">distributed</span>"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mr_map</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_id_reduce_id_dist_map</span> <span class="id">mr1</span> <span class="id">mr2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_id_reduce</span> <span class="id">mr1</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_id_dist_map</span> <span class="id">mr2</span>.(<span class="id">mr_map</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_id_reduce_id_dist_map_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_id_reduce_id_dist_map</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2622')">Proof.</div>
<div class="proofscript" id="proof2622">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_id_reduce_id_dist_map</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_reduce</span> (<span class="id">mr_reduce</span> <span class="id">mr1</span>) &amp;&amp; <span class="id">is_id_dist_map</span> (<span class="id">mr_map</span> <span class="id">mr2</span>)); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Htmp</span>, <span class="id">Hmr2_map_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Htmp</span> <span class="kwd">as</span> (<span class="id">Hmr1_mr2</span>, <span class="id">Hmr1_red_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> ((<span class="id">mr_map_eval</span> <span class="id">h</span> (<span class="id">mr_map</span> <span class="id">mr1</span>) <span class="id">loc_d</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_reduce_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr1_red_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_dist_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr2_map_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>) <span class="id">l</span>); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_singleton_reduce_id_scalar_map</span> <span class="id">mr1</span> <span class="id">mr2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_singleton_reduce</span> <span class="id">mr1</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_id_scalar_map</span> <span class="id">mr2</span>.(<span class="id">mr_map</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_singleton_reduce_id_scalar_map_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">loc_d</span>, <span class="id">exists</span> <span class="id">d</span>, <span class="id">mr_map_eval</span> <span class="id">h</span> <span class="id">mr1</span>.(<span class="id">mr_map</span>) <span class="id">loc_d</span> = <span class="id">Some</span> (<span class="id">d</span>::<span class="id">nil</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_singleton_reduce_id_scalar_map</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2623')">Proof.</div>
<div class="proofscript" id="proof2623">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmap1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_singleton_reduce_id_scalar_map</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_singleton_reduce</span> (<span class="id">mr_reduce</span> <span class="id">mr1</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_scalar_map</span> (<span class="id">mr_map</span> <span class="id">mr2</span>)); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Htmp</span>, <span class="id">Hmr2_map_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Htmp</span> <span class="kwd">as</span> (<span class="id">Hm1_m2</span>, <span class="id">Hmr1_red_is_single</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">Hmap1</span> <span class="id">loc_d</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmap1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">singleton_reduce_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr1_red_is_single</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_scalar_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr2_map_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>) (<span class="id">x</span> :: <span class="id">nil</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_reduce_id_flatten_map</span> (<span class="id">mr1</span> <span class="id">mr2</span>:<span class="id">mr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr1</span>.(<span class="id">mr_map</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapDist</span> <span class="id">map1</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_id_reduce</span> <span class="id">mr1</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_flatten_dist_map</span> <span class="id">mr2</span>.(<span class="id">mr_map</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MapDistFlatten</span> <span class="id">map1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_reduce_id_flatten_map_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_reduce_id_flatten_map</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2624')">Proof.</div>
<div class="proofscript" id="proof2624">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_reduce_id_flatten_map</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_map</span> <span class="id">mr1</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_id_reduce</span> (<span class="id">mr_reduce</span> <span class="id">mr1</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_flatten_dist_map</span> (<span class="id">mr_map</span> <span class="id">mr2</span>)); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Htmp</span>, <span class="id">Hmr2_map_is_flatten</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Htmp</span> <span class="kwd">as</span> (<span class="id">Hmr1_mr2</span>, <span class="id">Hmr1_red_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rmap</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">d</span> : <span class="id">data</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">doc</span>, <span class="id">body</span>) := <span class="id">p</span> <span class="kwd">in</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">doc</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">body</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">l</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">id_reduce_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr1_red_is_id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">flatten_dist_map_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr2_map_is_flatten</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">olift</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>)) (<span class="id">rflatten</span> <span class="id">l0</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_scalar_singleton_scalar</span> (<span class="id">mr1</span> <span class="id">mr2</span>: <span class="id">mr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>) <span class="id">mr2</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">is_singleton_reduce</span> <span class="id">mr1</span>.(<span class="id">mr_reduce</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr1</span>.(<span class="id">mr_map</span>), <span class="id">mr2</span>.(<span class="id">mr_map</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> (<span class="id">x1</span>, <span class="id">NNRCUnop</span> <span class="id">AColl</span> <span class="id">n1</span>), <span class="id">MapScalar</span> (<span class="id">x2</span>, <span class="id">n2</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">MapScalar</span> (<span class="id">x1</span>, <span class="id">NNRCLet</span> <span class="id">x2</span> <span class="id">n1</span> <span class="id">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">mr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMR</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span>.(<span class="id">mr_input</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_output</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr2</span>.(<span class="id">mr_reduce</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> <span class="id">mr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">merge_scalar_singleton_scalar_correct</span> <span class="id">mr1</span> <span class="id">mr2</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_well_formed</span> <span class="id">mr2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">merge_correct</span> <span class="id">merge_scalar_singleton_scalar</span> <span class="id">mr1</span> <span class="id">mr2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2625')">Proof.</div>
<div class="proofscript" id="proof2625">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">Hmr2_wf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_well_formed</span> <span class="kwd">in</span> <span class="id">Hmr2_wf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Hmr2_wf</span> <span class="kwd">as</span> [ <span class="id">Hmr2_map_wf</span> <span class="id">Hmr2_red_wf</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">Hmr2_red_wf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">mr3</span> <span class="id">Hcycle1</span> <span class="id">Hcycle2</span> <span class="id">Hcycle3</span> <span class="id">Hmerge_mr</span> <span class="id">loc_d</span> <span class="id">Hwell_localized</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_scalar_singleton_scalar</span> <span class="kwd">in</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_chain_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">equiv_dec</span> (<span class="id">mr_input</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr1</span>)); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mr_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">equiv_decb</span> (<span class="id">mr_output</span> <span class="id">mr1</span>) (<span class="id">mr_input</span> <span class="id">mr2</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_singleton_reduce</span> (<span class="id">mr_reduce</span> <span class="id">mr1</span>)); <span class="tactic">intros</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heq</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; [|<span class="tactic">congruence</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Bool.andb_true_iff</span> <span class="kwd">in</span> <span class="id">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heq</span> <span class="kwd">as</span> (<span class="id">Hmr1_mr2</span>, <span class="id">Hmr1_red_is_singleton</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">Hmerge_mr</span>; <span class="tactic">clear</span> <span class="id">Hmerge_mr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_map</span> <span class="id">mr1</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">mr_map</span> <span class="id">mr2</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">loc_d</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">n</span>); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">singleton_reduce_correct</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Hmr1_red_is_singleton</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">equiv_decb</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) <span class="id">n0</span> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v0</span>, <span class="id">d0</span>) :: (<span class="id">v</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">n0</span>) <span class="kwd">as</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="tactic">rewrite</span> <span class="id">Heq</span>; <span class="tactic">clear</span> <span class="id">Heq</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">apply</span> <span class="id">nnrc_core_eval_equiv_free_in_env</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">x</span> <span class="id">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> = <span class="id">v0</span>) <span class="kwd">as</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="tactic">rewrite</span> <span class="id">Heq</span>; <span class="tactic">clear</span> <span class="id">Heq</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">function_with_no_free_vars</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Hmr2_map_wf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v0</span>, <span class="id">d0</span>) :: (<span class="id">v</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">n0</span>); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">olift</span> (<span class="id">mr_reduce_eval</span> <span class="id">h</span> (<span class="id">mr_reduce</span> <span class="id">mr2</span>))); <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">merge_env</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">dest_eqdec</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d2</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_mr_last</span> <span class="id">mr</span> (<span class="id">last</span>: ((<span class="id">list</span> <span class="id">var</span> * <span class="id">nnrc</span>) * <span class="id">list</span> (<span class="id">var</span> * <span class="id">dlocalization</span>)) ) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '((<span class="id">params</span>, <span class="id">n</span>), <span class="id">args</span>) := <span class="id">last</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> (<span class="id">params</span>, <span class="id">args</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">x</span>::<span class="id">nil</span>, (<span class="id">output</span>, <span class="id">Vscalar</span>)::<span class="id">nil</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">equiv_decb</span> <span class="id">output</span> <span class="id">mr</span>.(<span class="id">mr_output</span>) &amp;&amp; <span class="id">is_singleton_reduce</span> <span class="id">mr</span>.(<span class="id">mr_reduce</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">mr_map</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">MapScalar</span> (<span class="id">x1</span>, <span class="id">NNRCUnop</span> <span class="id">AColl</span> <span class="id">n1</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> ((<span class="id">mr</span>.(<span class="id">mr_input</span>)::<span class="id">nil</span>, <span class="id">NNRCLet</span> <span class="id">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NNRCLet</span> <span class="id">x1</span> (<span class="id">NNRCVar</span> <span class="id">mr</span>.(<span class="id">mr_input</span>)) <span class="id">n1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr</span>.(<span class="id">mr_input</span>), <span class="id">Vscalar</span>)::<span class="id">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">_</span>, <span class="id">_</span>) =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">merge_last</span> <span class="id">mrl</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">chain</span>, <span class="id">output</span>, <span class="id">last</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">mr</span> <span class="id">chain_output_last</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">chain_output_last</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">nil</span>, <span class="id">None</span>, <span class="id">last</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">merge_mr_last</span> <span class="id">mr</span> <span class="id">last</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">last</span>' =&gt; (<span class="id">nil</span>, <span class="id">None</span>, <span class="id">last</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; (<span class="id">mr</span>::<span class="id">nil</span>, <span class="id">Some</span> (<span class="id">mr_output</span> <span class="id">mr</span>), <span class="id">last</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">acc</span>, <span class="id">output</span>, <span class="id">last</span>) =&gt; (<span class="id">mr</span>::<span class="id">acc</span>, <span class="id">output</span>, <span class="id">last</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">nil</span>, <span class="id">None</span>, <span class="id">mrl</span>.(<span class="id">mr_last</span>)) <span class="id">mrl</span>.(<span class="id">mr_chain</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">output</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">output</span> =&gt; <span class="id">Some</span> (<span class="id">mkMRChain</span> <span class="id">mrl</span>.(<span class="id">mr_inputs_loc</span>) <span class="id">chain</span> <span class="id">last</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_chain_apply_rewrite</span> (<span class="id">rew</span>: <span class="id">mr</span> -&gt; <span class="id">option</span> (<span class="id">list</span> <span class="id">mr</span>)) <span class="id">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.flat_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">mr</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">rew</span> <span class="id">mr</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">mr</span>::<span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">mr_chain</span> =&gt; <span class="id">mr_chain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">l</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">apply_rewrite</span> (<span class="id">rew</span>: <span class="id">mr</span> -&gt; <span class="id">option</span> (<span class="id">list</span> <span class="id">mr</span>)) <span class="id">mrl</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRChain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_inputs_loc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_apply_rewrite</span> <span class="id">rew</span> <span class="id">mrl</span>.(<span class="id">mr_chain</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_last</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_chain_apply_merge</span> (<span class="id">merge</span>: <span class="id">mr</span> -&gt; <span class="id">mr</span> -&gt; <span class="id">option</span> <span class="id">mr</span>) <span class="id">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">output_vars</span> : <span class="id">list</span> <span class="id">var</span> := <span class="id">List.fold_left</span> (<span class="kwd">fun</span> <span class="id">acc</span> <span class="id">mr</span> =&gt; <span class="id">mr</span>.(<span class="id">mr_output</span>) :: <span class="id">acc</span>) <span class="id">l</span> <span class="id">nil</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">mr1</span> <span class="id">acc</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">leb</span> (<span class="id">mult</span> <span class="id">output_vars</span> <span class="id">mr1</span>.(<span class="id">mr_output</span>)) 1 <span class="kwd">then</span>  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l_optimized</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">mr2</span> <span class="id">acc</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">merge</span> <span class="id">mr1</span> <span class="id">mr2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">mr2</span> :: <span class="id">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">mr12</span> =&gt; <span class="id">mr12</span> :: <span class="id">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nil</span> <span class="id">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span> :: <span class="id">l_optimized</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr1</span> :: <span class="id">acc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nil</span> <span class="id">l</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">apply_merge</span> (<span class="id">merge</span>: <span class="id">mr</span> -&gt; <span class="id">mr</span> -&gt; <span class="id">option</span> <span class="id">mr</span>) <span class="id">mrl</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRChain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_inputs_loc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_apply_merge</span> <span class="id">merge</span> <span class="id">mrl</span>.(<span class="id">mr_chain</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_last</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">mr_chain_cleanup</span> <span class="id">l</span> (<span class="id">to_keep</span>: <span class="id">list</span> <span class="id">var</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">to_keep</span>', <span class="id">res</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">r</span> (<span class="id">acc</span>: <span class="id">list</span> <span class="id">var</span> * <span class="id">list</span> <span class="id">mr</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">to_keep</span>, <span class="id">res</span>) := <span class="id">acc</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">in_dec</span> <span class="id">equiv_dec</span> <span class="id">r</span>.(<span class="id">mr_output</span>) <span class="id">to_keep</span> <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">r</span>.(<span class="id">mr_input</span>)::<span class="id">to_keep</span>, <span class="id">r</span>::<span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">to_keep</span>, <span class="id">res</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">to_keep</span>, <span class="id">nil</span>) <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">res</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_cleanup</span> <span class="id">mrl</span> <span class="id">to_keep</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRChain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_inputs_loc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mr_chain_cleanup</span> <span class="id">mrl</span>.(<span class="id">mr_chain</span>) <span class="id">to_keep</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mrl</span>.(<span class="id">mr_last</span>).<br/>
<br/>
&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_optimize_step</span> (<span class="id">l</span>: <span class="id">nnrcmr</span>): <span class="id">nnrcmr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">to_keep</span> := <span class="id">List.map</span> <span class="id">fst</span> (<span class="id">snd</span> <span class="id">l</span>.(<span class="id">mr_last</span>)) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_rewrite</span> <span class="id">map_collect_flatten_to_map_flatten_collect</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_id_reduce_id_dist_map</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_singleton_reduce_id_scalar_map</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_reduce_id_flatten_map</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_collect_dispatch</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_mr_id_dist_l</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_mr_id_scalar_l</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">apply_merge</span> <span class="id">merge_scalar_singleton_scalar</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_cleanup</span> <span class="id">l</span> <span class="id">to_keep</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">merge_last</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">l</span> =&gt; <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">l</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Fixpoint</span> <span class="id">mr_optimize_loop</span> <span class="id">n</span> (<span class="id">l</span>: <span class="id">nnrcmr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">S</span> <span class="id">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">l</span> := <span class="id">mr_optimize_step</span> <span class="id">l</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_optimize_loop</span> <span class="id">n</span> <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_optimize</span> (<span class="id">l</span>: <span class="id">nnrcmr</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_optimize_loop</span> 10 <span class="id">l</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">fresh_mr_var</span> (<span class="id">prefix</span>: <span class="id">string</span>) (<span class="id">vars</span>: <span class="id">list</span> <span class="id">var</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">x</span> := <span class="id">fresh_var</span> <span class="id">prefix</span> <span class="id">vars</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">x</span>, <span class="id">x</span>::<span class="id">vars</span>).<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">get_mr_chain_vars</span> <span class="id">mr_chain</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">acc</span> <span class="id">mr</span> =&gt; <span class="id">mr</span>.(<span class="id">mr_input</span>) :: <span class="id">mr</span>.(<span class="id">mr_output</span>) :: <span class="id">acc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mr_chain</span> <span class="id">nil</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">get_nnrcmr_vars</span> <span class="id">mrl</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">get_mr_chain_vars</span> <span class="id">mrl</span>.(<span class="id">mr_chain</span>).<br/>
<br/>
<span class="kwd">End</span> <span class="id">NNRCMRRewrite</span>.<br/>
<br/>
<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
