
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Qcert.CldMR.Lang.CldMR</title>
<meta name="description" content="Documentation of Coq module Qcert.CldMR.Lang.CldMR" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Qcert.CldMR.Lang.CldMR</h1>
<div class="coq">
<br/>
<div class="doc">CldMR is a language to describe chains of Map/Reduce views in the
Cloudant Database, followed by some local computation over the result
of the views. </div>
<br/>
<div class="doc">Cloudant's notion of 'views' provides some of the capabilities
    that are available in more common Map/Reduce framework such as Hadoop,
    but has a number of different properties. </div>
<br/>
<div class="doc">Cloudant notion of views is less expressive than general purpose
    Map/Reduce but offers the following additional capabilities:
<ul>
<li>
 Cloudant views can be chained through a special directive called
  dbcopy which creates a new database that can be the input to a
  subsequent Cloudant view.
</li>
<li>
 Cloudant views are computed in an incremental fashion, i.e., changes
  on the input are propagated with limited recomputation and
  exploiting results from previous executions which are cached. </li>
</ul>
</div>
<br/>
<div class="doc">To achieve that, Cloudant views relies on a number of invariants,
    which we expose and try to enforce. The most important invariants
    are:
<ul>
<li>
 A <span class="bracket"><span class="id">dbcopy</span></span> can only be present if a reduce is present as well.
</li>
<li>
 the result of a <span class="bracket"><span class="id">dbcopy</span></span> directive is implicitely coerced into a a
  database in the form of key/value pairs, which are used to populate
  the newly created database/view.
</li>
<li>
 A subsequent map over that dbcopy must access data accordingly (in
  such key/values JSON structure).
</li>
<li>
 The "reduce" part of Cloudant views is heavily constrained and must
  provide two distinct functions: one called <span class="bracket"><span class="id">reduce</span></span>, the other
  called <span class="bracket"><span class="id">rereduce</span></span>. The <span class="bracket"><span class="id">rereduce</span></span> function must be associative and
  commutative.  </li>
</ul>
</div>
<br/>
<div class="doc">Finally, Cloudant views support special purposes reducers for the
most common aggregate functions (count, sum, and average). We provide
a representation to take advantage of those. </div>
<br/>
<div class="doc">Summary:
<ul>
<li>
 Language: CldMR (Cloudant Map/Reduce)
</li>
<li>
 Based on: Cloudant DB documentation.
</li>
<li>
 URL: https://console.ng.bluemix.net/docs/services/Cloudant/api/creating_views.html#views-mapreduce-
</li>
<li>
 Languages translating to CldMR: NNRCMR
</li>
<li>
 Languages translating from CldMR: Cloudant
</li>
</ul>
</div>
<br/>
<span class="kwd">Section</span> <span class="id">CldMR</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">String</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">List</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Sorting.Mergesort</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">EquivDec</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Utils</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">BasicRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">cNNRCRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">NNRCMRRuntime</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CldMRUtil</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ForeignCloudant</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">list_scope</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> {<span class="id">fruntime</span>:<span class="id">foreign_runtime</span>}.<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> {<span class="id">fredop</span>:<span class="id">foreign_reduce_op</span>}.<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> {<span class="id">fcloudant</span>:<span class="id">foreign_cloudant</span>}.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Context</span> (<span class="id">h</span>:<span class="id">list</span>(<span class="id">string</span>*<span class="id">string</span>)).<br/>
<br/>
<h1> Abstract Syntax </h1>
<br/>
<div class="doc">As in NNRCMR, all local computation inside the map or the reduce
  in CldMR is described using NNRC expressions. </div>
&nbsp;&nbsp;<br/>
<h2> Map </h2>
&nbsp;&nbsp;<br/>
<div class="doc">The <span class="bracket"><span class="id">map</span></span> part of a Cloudant view is described using two
  components:
<ul>
<li>
 a map function which can be either a map or a flat_map, which is
  applied to every document in the input database.
</li>
<li>
 an emit function which controls the generation of keys passed to the
  reduce. The emit function is either: (i) <span class="bracket"><span class="id">dist</span></span> which creates unique
  id's for the result of the map and results in a distributed
  collection, (ii) <span class="bracket"><span class="id">collect</span></span> which is enforcing accumulation to a
  single output document with a single key. </li>
</ul>
</div>
<br/>
<div class="doc">Note that as opposed to NNRCMR, the collect is specified in the
  map rather than the reduce, since it has to be controlled through an
  emit. </div>
&nbsp;&nbsp;<br/>
<div class="doc">Also note that this model does not cover a group-by semantics
  but only simpler forms of reduce. </div>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">cld_map_fun</span> :=<br/>
&nbsp;&nbsp;| <span class="id">CldMapId</span> : <span class="id">var</span> * <span class="id">nnrc</span> -&gt; <span class="id">cld_map_fun</span>           <span class="docright">(* <span class="bracket"><span class="id">A</span> -&gt; <span class="id">B</span></span>  *)</span><br/>
&nbsp;&nbsp;| <span class="id">CldMapFlatten</span> : <span class="id">var</span> * <span class="id">nnrc</span> -&gt; <span class="id">cld_map_fun</span>.     <span class="docright">(* <span class="bracket"><span class="id">A</span> -&gt; <span class="id">coll</span> <span class="id">B</span></span>  *)</span><br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">cld_map_emit</span> :=<br/>
&nbsp;&nbsp;| <span class="id">CldEmitDist</span> : <span class="id">cld_map_emit</span>                     <span class="docright">(* Emit one key per input document  *)</span><br/>
&nbsp;&nbsp;| <span class="id">CldEmitCollect</span> : <span class="id">nat</span> -&gt; <span class="id">cld_map_emit</span>.          <span class="docright">(* Emit a single key for all documents  *)</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">cld_map</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMapCld</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">map_fun</span>: <span class="id">cld_map_fun</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_emit</span>: <span class="id">cld_map_emit</span> }.<br/>
<br/>
<h2> Reduce </h2>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">cld_numeric_type</span> :=<br/>
&nbsp;&nbsp;| <span class="id">Cld_int</span><br/>
&nbsp;&nbsp;| <span class="id">Cld_float</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Global</span> <span class="kwd">Instance</span> <span class="id">cld_numeric_type_eqdec</span> : <span class="id">EqDec</span> <span class="id">cld_numeric_type</span> <span class="id">eq</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2707')">Proof.</div>
<div class="proofscript" id="proof2707">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">unfold</span> <span class="id">equiv</span>, <span class="id">complement</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> (<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> : <span class="id">cld_numeric_type</span>, {<span class="id">x</span> = <span class="id">y</span>} + {<span class="id">x</span> &lt;&gt; <span class="id">y</span>}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
&nbsp;&nbsp;Defined.</div>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">cld_reduce_op</span> :=<br/>
&nbsp;&nbsp;| <span class="id">CldRedOpCount</span> : <span class="id">cld_reduce_op</span>                          <span class="docright">(* Special reducer: <span class="bracket"><span class="id">_count</span></span>  *)</span><br/>
&nbsp;&nbsp;| <span class="id">CldRedOpSum</span> (<span class="id">typ</span>:<span class="id">cld_numeric_type</span>): <span class="id">cld_reduce_op</span>      <span class="docright">(* Special reducer: <span class="bracket"><span class="id">_sum</span></span>  *)</span><br/>
&nbsp;&nbsp;| <span class="id">CldRedOpStats</span> (<span class="id">typ</span>:<span class="id">cld_numeric_type</span>): <span class="id">cld_reduce_op</span>.   <span class="docright">(* Special reducer: <span class="bracket"><span class="id">_stat</span></span>  *)</span><br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Inductive</span> <span class="id">cld_reduce_fun</span> :=<br/>
&nbsp;&nbsp;| <span class="id">CldRedId</span> : <span class="id">cld_reduce_fun</span>                                 <span class="docright">(* Reduce is identity  *)</span><br/>
&nbsp;&nbsp;| <span class="id">CldRedAggregate</span> :                                         <span class="docright">(* Arbitrary reduce + rereduce  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">var</span> * <span class="id">var</span>) * <span class="id">nnrc</span>) -&gt; (<span class="id">var</span> * <span class="id">nnrc</span>) -&gt; <span class="id">cld_reduce_fun</span><br/>
&nbsp;&nbsp;| <span class="id">CldRedOp</span> : <span class="id">cld_reduce_op</span> -&gt; <span class="id">cld_reduce_fun</span>.               <span class="docright">(* Special reducer  *)</span><br/>
<br/>
<div class="doc">In the case of the arbirary reduce operation: the first function
      is the <span class="bracket"><span class="id">reduce</span></span> and applied once on each key/value pair
      resulting from the map <span class="bracket">(<span class="id">K</span> * <span class="id">list</span> <span class="id">B</span>) -&gt; <span class="id">C</span></span>; the second function
      is the <span class="bracket"><span class="id">rereduce</span></span> and applied on the result of the first
      function <span class="bracket">(<span class="id">list</span> <span class="id">C</span>) -&gt; <span class="id">C</span></span>. </div>
<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">cld_reduce</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkReduceCld</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">reduce_fun</span>: <span class="id">cld_reduce_fun</span>;   <span class="docright">(* reduce function  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reduce_output</span> : <span class="id">option</span> <span class="id">var</span> }. <span class="docright">(* Output database <span class="bracket"><span class="id">dbcopy</span></span>  *)</span><br/>
<br/>
<h2> Map/Reduce View </h2>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">cldmr_step</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRCld</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">cldmr_step_input</span>: <span class="id">var</span>;                    <span class="docright">(* Input database  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_map</span>: <span class="id">cld_map</span>;                  <span class="docright">(* Map  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_reduce</span>: <span class="id">option</span> <span class="id">cld_reduce</span>;     <span class="docright">(* Reduce  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_reduce_default</span>: <span class="id">option</span> <span class="id">nnrc</span> }. <span class="docright">(* Default when database is empty  *)</span><br/>
<br/>
<h2> Map/Reduce Chains </h2>
<br/>
<div class="doc">The top-level data structure includes a list of Map/Reduce
  views, followed by an additional expressions which is used to gather
  all the results from the views and compute the final results. This
  is meant to be evaluated locally. </div>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Record</span> <span class="id">cldmr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRCldChain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">cldmr_chain</span>: <span class="id">list</span> <span class="id">cldmr_step</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_last</span>: ((<span class="id">list</span> <span class="id">var</span>) * <span class="id">nnrc</span>) * (<span class="id">list</span> <span class="id">var</span>) }.<br/>
<br/>
<br/>
<br/>
<h1> Well-formed properties </h1>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_causally_consistent</span> (<span class="id">mr1</span> <span class="id">mr2</span>:<span class="id">cldmr_step</span>) : <span class="id">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="kwd">match</span> <span class="id">mr2</span>.(<span class="id">cldmr_step_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">r</span>.(<span class="id">reduce_output</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">o</span> =&gt; <span class="id">mr1</span>.(<span class="id">cldmr_step_input</span>) &lt;&gt;<span class="id">b</span> <span class="id">o</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_chain_causally_consistent</span> : <span class="id">list</span> <span class="id">cldmr_step</span> -&gt; <span class="id">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">forallb_ordpairs_refl</span> <span class="id">cldmr_step_causally_consistent</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_causally_consistent</span> (<span class="id">cldmr</span>: <span class="id">cldmr</span>) : <span class="id">bool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">cldmr_chain_causally_consistent</span> <span class="id">cldmr</span>.(<span class="id">cldmr_chain</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_io_vars</span> <span class="id">mr0</span> : <span class="id">list</span> <span class="id">var</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">mr0</span>.(<span class="id">cldmr_step_input</span>)::<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr0</span>.(<span class="id">cldmr_step_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">r</span>.(<span class="id">reduce_output</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">o</span> =&gt; <span class="id">o</span>::<span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">mr_chain_io_vars</span> (<span class="id">l</span> : <span class="id">list</span> <span class="id">mr</span>) : <span class="id">list</span> <span class="id">var</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">map</span> <span class="id">mr_input</span> <span class="id">l</span> ++ <span class="id">map</span> <span class="id">mr_output</span> <span class="id">l</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">nnrcmr_io_vars</span> (<span class="id">mrl</span> : <span class="id">nnrcmr</span>) : <span class="id">list</span> <span class="id">var</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">mr_chain_io_vars</span> <span class="id">mrl</span>.(<span class="id">mr_chain</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_chain_io_vars</span> : <span class="id">list</span> <span class="id">cldmr_step</span> -&gt; <span class="id">list</span> <span class="id">var</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">flat_map</span> <span class="id">cldmr_step_io_vars</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_io_vars</span> (<span class="id">cldmr</span>:<span class="id">cldmr</span>): <span class="id">list</span> <span class="id">var</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id">cldmr_chain_io_vars</span> <span class="id">cldmr</span>.(<span class="id">cldmr_chain</span>).<br/>
<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">function_with_no_free_vars</span> (<span class="id">f</span>: <span class="id">var</span> * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> (<span class="id">x</span>: <span class="id">var</span>), <span class="id">In</span> <span class="id">x</span> (<span class="id">nnrc_free_vars</span> (<span class="id">snd</span> <span class="id">f</span>)) -&gt; <span class="id">x</span> = <span class="id">fst</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">function2_with_no_free_vars</span> (<span class="id">f</span>: (<span class="id">var</span> * <span class="id">var</span>) * <span class="id">nnrc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fst</span> (<span class="id">fst</span> <span class="id">f</span>)) &lt;&gt; (<span class="id">snd</span> (<span class="id">fst</span> <span class="id">f</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">In</span> <span class="id">x</span> (<span class="id">nnrc_free_vars</span> (<span class="id">snd</span> <span class="id">f</span>)) -&gt; <span class="id">x</span> = (<span class="id">fst</span> (<span class="id">fst</span> <span class="id">f</span>)) \/ <span class="id">x</span> = (<span class="id">snd</span> (<span class="id">fst</span> <span class="id">f</span>))).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">init_vkey</span> := "<span class="id">vkey</span>$"%<span class="id">string</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">init_vval</span> := "<span class="id">vval</span>$"%<span class="id">string</span>.<br/>
<br/>
<h1> Evaluation Semantics </h1>
<br/>
<br/>
<div class="doc">A few useful functions for key manipulation, lifting and
  building the initial CldMR environment. </div>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">add_keys_to_binding</span> (<span class="id">binding</span>: <span class="id">string</span> * (<span class="id">list</span> <span class="id">data</span>)) : <span class="id">string</span> * <span class="id">data</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fst</span> <span class="id">binding</span>, <span class="id">pack_kvl</span> (<span class="id">init_keys</span> (<span class="id">snd</span> <span class="id">binding</span>))).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">lift_binding_to_coll</span> (<span class="id">binding</span>: <span class="id">string</span> * <span class="id">data</span>) : <span class="id">option</span> (<span class="id">string</span> * (<span class="id">list</span> <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">snd</span> <span class="id">binding</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">dcoll</span> <span class="id">coll</span> =&gt; <span class="id">Some</span> (<span class="id">fst</span> <span class="id">binding</span>, <span class="id">coll</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The evaluation relies on the existence of an initial database
  containing a single document with the unit value. This is necessary
  in order to trigger computation when all other input databases are
  empty. </div>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cld_load_init_env</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">initunit</span>: <span class="id">var</span>) (<span class="id">cenv</span>: <span class="id">list</span> (<span class="id">string</span> * <span class="id">data</span>)) : <span class="id">option</span> <span class="id">bindings</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lift_map</span> <span class="id">lift_binding_to_coll</span> <span class="id">cenv</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">cenv</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">full_bindings</span> := (<span class="id">initunit</span>, (<span class="id">dunit</span>::<span class="id">nil</span>)) :: <span class="id">cenv</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">map</span> <span class="id">add_keys_to_binding</span> <span class="id">full_bindings</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<h2> Map </h2>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">apply_map_fun_with_keys</span> (<span class="id">doc</span>:<span class="id">var</span>) (<span class="id">body</span>:<span class="id">nnrc</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) -&gt; <span class="id">option</span> (<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">coll</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">f_map</span> (<span class="id">d</span>:<span class="id">data</span>*<span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">k</span>, <span class="id">v</span>) := <span class="id">d</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">doc</span>,<span class="id">v</span>)::<span class="id">nil</span>) <span class="id">body</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">Some</span> (<span class="id">k</span>, <span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">rmap</span> <span class="id">f_map</span> <span class="id">coll</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">apply_map_fun_without_keys</span> (<span class="id">doc</span>:<span class="id">var</span>) (<span class="id">body</span>:<span class="id">nnrc</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) -&gt; <span class="id">option</span> (<span class="id">list</span> <span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">coll</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">f_map</span> (<span class="id">d</span>:<span class="id">data</span>*<span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">_</span>, <span class="id">v</span>) := <span class="id">d</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">doc</span>,<span class="id">v</span>)::<span class="id">nil</span>) <span class="id">body</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">Some</span> <span class="id">res</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">rmap</span> <span class="id">f_map</span> <span class="id">coll</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_map_eval</span> (<span class="id">map</span>: <span class="id">cld_map</span>) (<span class="id">coll</span>: <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) : <span class="id">option</span> (<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">map_f</span> := <span class="id">map</span>.(<span class="id">map_fun</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">emit_f</span> := <span class="id">map</span>.(<span class="id">map_emit</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">map_f</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldMapId</span> (<span class="id">doc</span>, <span class="id">body</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">emit_f</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldEmitDist</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">nested_map</span> := <span class="id">apply_map_fun_with_keys</span> <span class="id">doc</span> <span class="id">body</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nested_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldEmitCollect</span> <span class="id">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">nested_map</span> := <span class="id">apply_map_fun_without_keys</span> <span class="id">doc</span> <span class="id">body</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="id">map_without_key</span> (<span class="id">map_const_key</span> <span class="id">n</span>)) <span class="id">nested_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldMapFlatten</span> (<span class="id">doc</span>, <span class="id">body</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">emit_f</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldEmitDist</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">nested_map</span> := <span class="id">apply_map_fun_with_keys</span> <span class="id">doc</span> <span class="id">body</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="id">flat_map_with_key</span> <span class="id">map_invent_key</span>) <span class="id">nested_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldEmitCollect</span> <span class="id">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">nested_map</span> := <span class="id">apply_map_fun_without_keys</span> <span class="id">doc</span> <span class="id">body</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">flattened_map</span> := <span class="id">olift</span> <span class="id">flat_map_without_key</span> <span class="id">nested_map</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="id">map_without_key</span> (<span class="id">map_const_key</span> <span class="id">n</span>)) <span class="id">flattened_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">mapIdDist_is_map</span> (<span class="id">map</span>:<span class="id">var</span>*<span class="id">nnrc</span>) (<span class="id">coll</span>:<span class="id">list</span> <span class="id">data</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> <span class="id">cld_get_values</span> (<span class="id">cldmr_step_map_eval</span> (<span class="id">mkMapCld</span> (<span class="id">CldMapId</span> <span class="id">map</span>) (<span class="id">CldEmitDist</span>)) (<span class="id">init_keys</span> <span class="id">coll</span>)) = (<span class="id">mr_map_eval</span> <span class="id">h</span> (<span class="id">MapDist</span> <span class="id">map</span>) (<span class="id">Ddistr</span> <span class="id">coll</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2708')">Proof.</div>
<div class="proofscript" id="proof2708">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cldmr_step_map_eval</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">init_keys</span>; <span class="tactic">generalize</span> 0.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">coll</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">map</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">map</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">apply_map_fun_with_keys</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">a</span>) :: <span class="id">nil</span>) <span class="id">n0</span>); <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">IHcoll</span> (<span class="id">S</span> <span class="id">n</span>)); <span class="tactic">simpl</span>; <span class="tactic">clear</span> <span class="id">IHcoll</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">init_keys_aux</span> <span class="id">nil</span> (<span class="id">S</span> <span class="id">n</span>) <span class="id">coll</span>); <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">d1</span>) :: <span class="id">nil</span>) <span class="id">n0</span>); <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> ((<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">t</span>' : <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) =&gt; (<span class="id">d0</span>, <span class="id">d2</span>) :: <span class="id">t</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rmap</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">d3</span> : <span class="id">data</span> * <span class="id">data</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">k</span>, <span class="id">v0</span>) := <span class="id">d3</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">v</span>, <span class="id">v0</span>) :: <span class="id">nil</span>) <span class="id">n0</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">Some</span> (<span class="id">k</span>, <span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>) <span class="id">l</span>))); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">box_key</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cld_get_values</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">lift_map_boxed_cons</span> <span class="id">n</span> <span class="id">d</span> <span class="id">coll</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">kvs</span> : <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) =&gt; <span class="id">map</span> <span class="id">snd</span> <span class="id">kvs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">t</span>' : <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) =&gt; (<span class="id">box_key</span> (<span class="id">n</span> :: <span class="id">nil</span>), <span class="id">d</span>) :: <span class="id">t</span>') <span class="id">coll</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id">lift</span> (<span class="id">cons</span> <span class="id">d</span>) (<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">kvs</span> : <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>) =&gt; <span class="id">map</span> <span class="id">snd</span> <span class="id">kvs</span>) <span class="id">coll</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2709')">Proof.</div>
<div class="proofscript" id="proof2709">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">coll</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<h2> Reduce </h2>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_group_by_eval</span> (<span class="id">l</span>: <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) : <span class="id">list</span> (<span class="id">data</span> * (<span class="id">list</span> <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">group_by_iter_eval_alt</span> <span class="id">l</span>.<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_aggregate_eval</span> (<span class="id">f_reduce</span>: (<span class="id">var</span> * <span class="id">var</span>) * <span class="id">nnrc</span>) (<span class="id">f_rereduce</span>: (<span class="id">var</span> * <span class="id">nnrc</span>)) (<span class="id">groups</span>: <span class="id">list</span> (<span class="id">data</span> * (<span class="id">list</span> <span class="id">data</span>)))  : <span class="id">option</span> (<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">key_values_args</span>, <span class="id">body</span>) := <span class="id">f_reduce</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">key_arg</span>, <span class="id">values_arg</span>) := <span class="id">key_values_args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">f_reduce</span> (<span class="id">key_values_v</span>: <span class="id">data</span> * <span class="id">list</span> <span class="id">data</span>) : <span class="id">option</span> (<span class="id">data</span> * <span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">key_v</span>, <span class="id">values_v</span>) := <span class="id">key_values_v</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">values_arg</span>, <span class="id">dcoll</span> <span class="id">values_v</span>) :: (<span class="id">key_arg</span>, <span class="id">key_v</span>) :: <span class="id">nil</span>) <span class="id">body</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">Some</span> (<span class="id">key_v</span>, <span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">reduced</span> := <span class="id">rmap</span> <span class="id">f_reduce</span> <span class="id">groups</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">f_rereduce</span> (<span class="id">key_value_v</span>: (<span class="id">data</span> * <span class="id">data</span>)) : <span class="id">option</span> (<span class="id">data</span> * <span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">key_v</span>, <span class="id">value_v</span>) := <span class="id">key_value_v</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> '(<span class="id">values_arg</span>, <span class="id">rebody</span>) := <span class="id">f_rereduce</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> ((<span class="id">values_arg</span>, <span class="id">dcoll</span> (<span class="id">value_v</span>::<span class="id">nil</span>)) :: <span class="id">nil</span>) <span class="id">rebody</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">Some</span> (<span class="id">key_v</span>, <span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="id">rmap</span> <span class="id">f_rereduce</span>) <span class="id">reduced</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cloudant_sum_op</span> (<span class="id">typ</span>:<span class="id">cld_numeric_type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="kwd">match</span> <span class="id">typ</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_int</span> =&gt; <span class="id">ASum</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_float</span> =&gt; <span class="id">cloudant_float_sum_op</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cloudant_min_op</span> (<span class="id">typ</span>:<span class="id">cld_numeric_type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="kwd">match</span> <span class="id">typ</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_int</span> =&gt; <span class="id">ANumMin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_float</span> =&gt; <span class="id">cloudant_float_min_op</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cloudant_max_op</span> (<span class="id">typ</span>:<span class="id">cld_numeric_type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="kwd">match</span> <span class="id">typ</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_int</span> =&gt; <span class="id">ANumMax</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Cld_float</span> =&gt; <span class="id">cloudant_float_max_op</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_reduce_eval</span> (<span class="id">red_fun</span>: <span class="id">cld_reduce_fun</span>) (<span class="id">coll</span>: <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>))  : <span class="id">option</span> (<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">red_fun</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldRedId</span> =&gt; <span class="id">Some</span> <span class="id">coll</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldRedAggregate</span> <span class="id">f_reduce</span> <span class="id">f_rereduce</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">groups</span> := <span class="id">cldmr_step_group_by_eval</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_aggregate_eval</span> <span class="id">f_reduce</span> <span class="id">f_rereduce</span> <span class="id">groups</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldRedOp</span> <span class="id">CldRedOpCount</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">uop</span> := <span class="id">ACount</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">v</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> <span class="id">uop</span> (<span class="id">dcoll</span> (<span class="id">List.map</span> <span class="id">snd</span> <span class="id">coll</span>)) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">key</span> := <span class="id">dcoll</span> (<span class="id">dnat</span> 0::<span class="id">nil</span>) <span class="kwd">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">res</span> =&gt; (<span class="id">key</span>, <span class="id">res</span>)::<span class="id">nil</span>) <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldRedOp</span> (<span class="id">CldRedOpSum</span> <span class="id">typ</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">uop</span> := <span class="id">cloudant_sum_op</span> <span class="id">typ</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">v</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> <span class="id">uop</span> (<span class="id">dcoll</span> (<span class="id">List.map</span> <span class="id">snd</span> <span class="id">coll</span>)) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">key</span> := <span class="id">dcoll</span> (<span class="id">dnat</span> 0::<span class="id">nil</span>) <span class="kwd">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">res</span> =&gt; (<span class="id">key</span>, <span class="id">res</span>)::<span class="id">nil</span>) <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">CldRedOp</span> (<span class="id">CldRedOpStats</span> <span class="id">typ</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">coll</span> := <span class="id">dcoll</span> (<span class="id">List.map</span> <span class="id">snd</span> <span class="id">coll</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">count</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> <span class="id">ACount</span> <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">sum</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> (<span class="id">cloudant_sum_op</span> <span class="id">typ</span>) <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">min</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> (<span class="id">cloudant_min_op</span> <span class="id">typ</span>) <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">max</span> := <span class="id">fun_of_unaryop</span> <span class="id">h</span> (<span class="id">cloudant_max_op</span> <span class="id">typ</span>) <span class="id">coll</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">v</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> (<span class="id">count</span>, <span class="id">sum</span>, <span class="id">min</span>, <span class="id">max</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">Some</span> <span class="id">count</span>, <span class="id">Some</span> <span class="id">sum</span>, <span class="id">Some</span> <span class="id">min</span>, <span class="id">Some</span> <span class="id">max</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">drec</span> (("<span class="id">count</span>"%<span class="id">string</span>, <span class="id">count</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::("<span class="id">max</span>"%<span class="id">string</span>, <span class="id">max</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::("<span class="id">min</span>"%<span class="id">string</span>, <span class="id">min</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::("<span class="id">sum</span>"%<span class="id">string</span>, <span class="id">sum</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::<span class="id">nil</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">key</span> := <span class="id">dcoll</span> (<span class="id">dnat</span> 0::<span class="id">nil</span>) <span class="kwd">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">res</span> =&gt; (<span class="id">key</span>, <span class="id">res</span>)::<span class="id">nil</span>) <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">cldmr_step_reduce_flatten_id</span> (<span class="id">l</span>:<span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">cldmr_step_reduce_eval</span> <span class="id">CldRedId</span> <span class="id">l</span>) = <span class="id">Some</span> <span class="id">l</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2710')">Proof.</div>
<div class="proofscript" id="proof2710">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<br/>
<h2> Map/Reduce View </h2>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_eval</span> (<span class="id">mr</span>:<span class="id">cldmr_step</span>) (<span class="id">coll</span>: <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) : <span class="id">option</span> ((<span class="id">list</span> (<span class="id">data</span>*<span class="id">data</span>)) * <span class="id">option</span> <span class="id">var</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">map_result</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_map_eval</span> <span class="id">mr</span>.(<span class="id">cldmr_step_map</span>) <span class="id">coll</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">mr</span>.(<span class="id">cldmr_step_reduce</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>,<span class="id">None</span>)) <span class="id">map_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">reduce</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">reduce_result</span> := <span class="id">olift</span> (<span class="id">cldmr_step_reduce_eval</span> <span class="id">reduce</span>.(<span class="id">reduce_fun</span>)) <span class="id">map_result</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">x</span> =&gt; (<span class="id">x</span>, <span class="id">reduce</span>.(<span class="id">reduce_output</span>))) <span class="id">reduce_result</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<h2> Map/Reduce Chain </h2>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cld_merge_env</span> (<span class="id">x</span>: <span class="id">var</span>) (<span class="id">coll</span>: <span class="id">list</span> <span class="id">data</span>) (<span class="id">env</span>: <span class="id">bindings</span>) : <span class="id">option</span> <span class="id">bindings</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lookup</span> <span class="id">equiv_dec</span> <span class="id">env</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">Some</span> ((<span class="id">x</span>, <span class="id">dcoll</span> <span class="id">coll</span>)::<span class="id">env</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">d</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">dcoll</span> <span class="id">coll</span>' =&gt; <span class="id">Some</span> ((<span class="id">x</span>, <span class="id">dcoll</span> (<span class="id">coll</span> ++ <span class="id">coll</span>') )::<span class="id">env</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">nnrc_env_of_cld_env</span> (<span class="id">form</span>:<span class="id">list</span> <span class="id">var</span>) (<span class="id">eff</span>: <span class="id">option</span> (<span class="id">list</span> <span class="id">data</span>)): <span class="id">option</span> <span class="id">bindings</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="id">zip</span> <span class="id">form</span>) <span class="id">eff</span>. <br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">effective_params_from_bindings</span> (<span class="id">eff</span>:<span class="id">list</span> <span class="id">var</span>) (<span class="id">cld_env</span>:<span class="id">bindings</span>) : <span class="id">option</span> (<span class="id">list</span> <span class="id">data</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift_map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> (<span class="id">v</span> : <span class="id">var</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lookup</span> <span class="id">equiv_dec</span> <span class="id">cld_env</span> <span class="id">v</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">db</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lift</span> (<span class="kwd">fun</span> <span class="id">l</span> =&gt; <span class="id">dcoll</span> (<span class="id">List.map</span> <span class="id">snd</span> <span class="id">l</span>)) (<span class="id">unpack_kvl</span> <span class="id">db</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eff</span>.<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_step_eval_last</span> (<span class="id">cld_env</span>:<span class="id">bindings</span>) (<span class="id">mr_last</span>: ((<span class="id">list</span> <span class="id">var</span>) * <span class="id">nnrc</span>) * (<span class="id">list</span> <span class="id">var</span>)) : <span class="id">option</span> <span class="id">data</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">formal_params</span>, <span class="id">n</span>) := <span class="id">fst</span> <span class="id">mr_last</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">effective_params</span> := <span class="id">effective_params_from_bindings</span> (<span class="id">snd</span> <span class="id">mr_last</span>) <span class="id">cld_env</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">onrc_env</span> := <span class="id">nnrc_env_of_cld_env</span> <span class="id">formal_params</span> <span class="id">effective_params</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="kwd">fun</span> <span class="id">nnrc_env</span> =&gt; <span class="id">nnrc_core_eval</span> <span class="id">h</span> <span class="id">empty_cenv</span> <span class="id">nnrc_env</span> <span class="id">n</span>) <span class="id">onrc_env</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_chain_eval_inner</span> (<span class="id">env</span>:<span class="id">bindings</span>) (<span class="id">l</span>:<span class="id">list</span> <span class="id">cldmr_step</span>) : <span class="id">option</span> (<span class="id">bindings</span> * <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>)) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> (<span class="id">acc</span>: <span class="id">option</span> (<span class="id">bindings</span> * <span class="id">list</span> (<span class="id">data</span> * <span class="id">data</span>))) <span class="id">mr</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">acc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">env</span>', <span class="id">_</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">cld_input</span> := <span class="id">mr</span>.(<span class="id">cldmr_step_input</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lookup</span> <span class="id">equiv_dec</span> <span class="id">env</span>' <span class="id">cld_input</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">kvl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">coll</span> := <span class="id">unpack_kvl</span> <span class="id">kvl</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">olift</span> (<span class="id">cldmr_step_eval</span> <span class="id">mr</span>) <span class="id">coll</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">res</span>,<span class="id">None</span>) =&gt; <span class="id">Some</span> (<span class="id">env</span>, <span class="id">res</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">res</span>,<span class="id">Some</span> <span class="id">x</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">env</span>'' := <span class="id">cld_merge_env</span> <span class="id">x</span> (<span class="id">pre_pack_kvl</span> <span class="id">res</span>) <span class="id">env</span>' <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">olift</span> (<span class="kwd">fun</span> <span class="id">env</span> =&gt; <span class="id">Some</span> (<span class="id">env</span>, <span class="id">res</span>)) <span class="id">env</span>''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">l</span> (<span class="id">Some</span> (<span class="id">env</span>,<span class="id">nil</span>)).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_eval</span> (<span class="id">env</span>:<span class="id">bindings</span>) (<span class="id">cldmr</span>:<span class="id">cldmr</span>) : <span class="id">option</span> <span class="id">data</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">cldmr_chain_eval_inner</span> <span class="id">env</span> <span class="id">cldmr</span>.(<span class="id">cldmr_chain</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">env_res</span>, <span class="id">coll</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cldmr_step_eval_last</span> <span class="id">env_res</span> <span class="id">cldmr</span>.(<span class="id">cldmr_last</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<h1> Map/Reduce Chain Library </h1>
<br/>
<div class="doc">The following are built-in map/reduce which are useful for
  translations purposes. </div>
<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">cldmr_step_library</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">idReduce</span> (<span class="id">v_out</span>:<span class="id">option</span> <span class="id">var</span>) : <span class="id">cld_reduce</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkReduceCld</span> <span class="id">CldRedId</span> <span class="id">v_out</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">collectReduce</span> (<span class="id">v_out</span>:<span class="id">option</span> <span class="id">var</span>) : <span class="id">cld_reduce</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkReduceCld</span> (<span class="id">CldRedAggregate</span> (<span class="id">init_vkey</span>, <span class="id">init_vval</span>, <span class="id">NNRCVar</span> <span class="id">init_vval</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">init_vval</span>, <span class="id">NNRCUnop</span> <span class="id">AFlatten</span> (<span class="id">NNRCVar</span> <span class="id">init_vval</span>))) <span class="id">v_out</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">opReduce</span> (<span class="id">op</span>: <span class="id">cld_reduce_op</span>) (<span class="id">v_out</span>:<span class="id">option</span> <span class="id">var</span>) : <span class="id">cld_reduce</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkReduceCld</span> (<span class="id">CldRedOp</span> <span class="id">op</span>) <span class="id">v_out</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">defaultMR</span> : <span class="id">cldmr_step</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">mkMRCld</span> <span class="id">init_vval</span> (<span class="id">mkMapCld</span> (<span class="id">CldMapId</span> (<span class="id">init_vval</span>, <span class="id">NNRCConst</span> <span class="id">dunit</span>)) (<span class="id">CldEmitCollect</span> (99%<span class="id">nat</span>))) <span class="id">None</span> <span class="id">None</span> .<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">cldmr_step_library</span>.<br/>
<br/>
<h1> Toplevel </h1>
<br/>
<div class="doc">Top-level evaluation is used externally by the Q*cert
  compiler. It is parameterized by a given database name for the
  'initial database'. It takes a CldMR chain and a global environment
  as input. </div>
<br/>
&nbsp;&nbsp;<span class="kwd">Section</span> <span class="id">Top</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">cldmr_eval_top</span> (<span class="id">vinit</span>:<span class="id">var</span>) (<span class="id">q</span>:<span class="id">cldmr</span>) (<span class="id">cenv</span>:<span class="id">bindings</span>) : <span class="id">option</span> <span class="id">data</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">cenv</span> := <span class="id">rec_sort</span> <span class="id">cenv</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">cld_load_init_env</span> <span class="id">vinit</span> <span class="id">cenv</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">cenv</span> =&gt; <span class="id">cldmr_eval</span> <span class="id">cenv</span> <span class="id">q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">End</span> <span class="id">Top</span>.<br/>
&nbsp;&nbsp;<br/>
<span class="kwd">End</span> <span class="id">CldMR</span>.<br/>
<br/>

</div>
<div class="footer"><hr/>Generated by <a href="https://github.com/xavierleroy/coq2html/">coq2html</div>
</body>
</html>
